..  Copyright (C)  Mark Guzdial, Barbara Ericson, Briana Morrison
    Permission is granted to copy, distribute and/or modify this document
    under the terms of the GNU Free Documentation License, Version 1.3 or
    any later version published by the Free Software Foundation; with
    Invariant Sections being Forward, Prefaces, and Contributor List,
    no Front-Cover Texts, and no Back-Cover Texts.  A copy of the license
    is included in the section entitled "GNU Free Documentation License".
	


Loops and Patterns with Words and Numbers
===========================================

.. |runbutton| image:: Figures/run-button.png

.. |teachernote| image:: Figures/teachernote.png
    :width: 25px
    :align: top
    :alt: teachernote


When Seymour Papert first started working with Wally Feurzeig and Danny Bobrow to develop Logo, they didn't have a turtle, robot or otherwise.  Instead, he had his child programmers play with words and numbers.

Playing with numbers
-----------------------

Python also knows how to play with numbers, and we can use them in much the same way that Seymour's students did.

What is the sum of all the numbers between 1 and 10?  Run this to get the answer.

.. activecode:: csp_numbers_1
	
    sum = 0  # Start out with nothing
    numbers = [1,2,3,4,5,6,7,8,9,10]
    for number in numbers:
      sum = sum + number
    print(sum)

Did you get 55?  That's the sum of all the numbers from 1 to 10

.. mchoicemf:: csp_numbers_product
   :answer_a: 55
   :answer_b: 0
   :answer_c: 3628800
   :answer_d: Error - number is too big
   :correct: c
   :feedback_a: No, that's the sum
   :feedback_b: No, that's what you get if you leave the sum as 0.  Multipying everything by 0 gets you 0
   :feedback_c: Yup -- that's 10!, 10*9*8*7*6*5*4*3*2*1
   :feedback_d: No, it should actually work

   Now, change the above program to get the product instead of the sum (e.g., replace `+` with `*`, and replace the `0` as the initial value of `sum` to `1`).  What did you get?


Teacher Note: Variables are just words
--------------------------------------
|teachernote| Once you change the program above in order to answer the question, you will see that is using the variable `sum` to represent the `product` of all the numbers in `numbers`.  We might even say that the right variable name is `factorial` since that's what computed.  The program would be *better* if we used the right name for the variable: `product` or `factorial` for `sum` once we switched to multiplication (`*`) from addition (`+`).  However, the program still *works*.  In the end, the names for the variables are there for *human* benefit, not machine.  The computer doesn't care if we name the program `xyzzy1776`.  It will *work* with a bad variable name.  It's just not as readable.  **Programs are for people, first.** We should pick names to be understandable to people.

Using Better Variable Names
-----------------------------

Let's write that program again with a better variable name.

.. activecode:: csp_numbers_factorial
	
    factorial = 1  # Start out with nothing
    numbers = [1,2,3,4,5,6,7,8,9,10]
    for number in numbers:
      factorial = factorial * number
    print(factorial)

Teacher Note: Assignment isn't equality
----------------------------------------
|teachernote| The accumulator pattern relies on the fact that the Python assignment, ``=``, is not mathematical equality.  There can be no number such that ``sum`` is equal to ``sum+number``?  There can be no number such that ``factorial`` is equal to ``factorial*number``.  It's important for students to read an assignment statement with a ``=`` as an **action**.  It says:

1. Figure out the value of the *right* side of the statement.
2. The name on the *left* side now means that value.

It's a two-step process.  So ``sum = sum+number`` means:

1. Figure out the value of ``sum + number``
2. The name ``sum`` now has that value.  It's a *new* value for an *old* name, ``sum``.

Making it easier to compute factorial
----------------------------------------

That long list of values in numbers, since it's in numerical order, can also be generated by the `range` function.  The `range` function can take two `input` values.  The first one is the starting value, and the last one is the ending value **BUT**, the range doesn't include that value.  If only *one* value is given as input to `range`, the list of numbers returned starts with zero.

.. activecode:: csp_numbers_range
	
    print range(10)
    print range(1,10)
    print range(11)
    print range(1,11)

.. mchoicemf:: csp_numbers_rangewhich
   :answer_a: 1 print range(10)
   :answer_b: 2 print range(1,10)
   :answer_c: 3 print range(11)
   :answer_d: 4 print range(1,11)
   :correct: d
   :feedback_a: No, that includes zero and doesn't include 10: [0,1,2,3,4,5,6,7,8,9]
   :feedback_b: No, that doesn't include 10: [1,2,3,4,5,6,7,8,9]
   :feedback_c: No, that includes zero: [0,1,2,3,4,5,6,7,8,9,10]
   :feedback_d: Yup! [1,2,3,4,5,6,7,8,9,10]

   Which one of the four lines in the last example actually give us the numbers we need to get the factorial of 10?

.. activecode:: csp_numbers_factorial2
	
    factorial = 1  # Start out with nothing
    numbers = range(1,11)
    for number in numbers:
      factorial = factorial * number
    print(factorial)

.. mchoicemf:: csp_numbers_rangewhich
   :answer_a: 121645100408832000
   :answer_b: 3628800
   :answer_c: 362880
   :answer_d: 2432902008176640000
   :correct: d
   :feedback_a: No, that's 19! (e.g., you changed the 11 to 20)
   :feedback_b: No, that's 10! (e.g., no change at all)
   :feedback_c: No that's 9! (e.g., you changed the 11 to 10)
   :feedback_d: Yup! That's 20! (e.g., you changed the 11 to 21)

   Change ONE number in the above program to tell us the factorial of 20

There's a Pattern Here!
------------------------

There's a pattern in these programs, a pattern that is common when processing data.  We call this the **Accumulator Pattern**.  In the first program above, we *accumulated* a sum into the accumulator `sum`.  In the last few programs, we *accumulated* a product into the variable `factorial`.

Here are the five steps in this pattern.

1. Set the accumulator variable to its initial value.  This is the value we want if there is no data to be processed.
2. Get all the data to be processed.
3. Step through all the data using a `for` loop so that the variable takes on each value in the data.
4. Combine each *piece* of the data into the accumulator.
5. Do something with the result

Using our pattern
-------------------

What is the sum of all the numbers between 0 and 100?  We can answer that easily using our pattern.

.. activecode:: csp_numbers_100
	
    # STEP 1: Initialize accumulator
    sum = 0  # Start out with nothing
    # STEP 2: GET DATA
    numbers = range(101)
    # STEP 3: STEP DATA
    for number in numbers:
      # STEP 4: COMBINE
      sum = sum + number
    # STEP 5: RESULT
    print(sum)

The `range` function has one more version that we can use here.  By providing *three* input numbers, we can specify the *start* value, the *ending* value (which is one more than the *last* value), and the *step* -- how much to skip *between* numbers.

.. activecode:: csp_range_skip

  print range(100)
  print range(1,100)
  print range(0,100,2)
  print range(0,100,3)

Now let's answer a slightly harder question: What is the sum of all the *even* numbers between 0 and 100?  It's easy with our pattern.
  
.. activecode:: csp_numbers_100stepped
	
    # STEP 1: Initialize accumulator
    sum = 0  # Start out with nothing
    # STEP 2: GET DATA
    numbers = range(0,101,2)
    # STEP 3: STEP DATA
    for number in numbers:
      # STEP 4: COMBINE
      sum = sum + number
    # STEP 5: RESULT
    print(sum)

.. mchoicemf:: csp_numbers_why101
   :answer_a: Because we started at 0
   :answer_b: Because we want to include 100
   :answer_c: Because the computer only understands 1s and 0s
   :answer_d: Because we're using a step of 2
   :correct: b
   :feedback_a: No, we would want to include 100.
   :feedback_b: Exactly! And if we stop BEFORE 101, we include 100.
   :feedback_c: Internally, yes, but in Python, all decimal digits are allowed.
   :feedback_d: No, that doesn't really matter.

   Why do we stop at 101 in the above program?

.. mchoicemf:: csp_numbers_why101
   :answer_a: Because if we started with 1, we would get all odd numbers
   :answer_b: Because all arrays start with zero
   :answer_c: Because we end with 101
   :correct: a
   :feedback_a: Yes -- this gives us [0,2,4,6...98,100].
   :feedback_b: That is true but not relevant here.
   :feedback_c: That is true but not relevant here.

   Why do we START with zero?

How do we know what's really going on in this program?  How do we know that *number* is taking on all of the values from 0 to 100?  One way we can tell is by using a Code Lens, to step through the program line-by-line, or race to the end and step backwards.

.. codelens:: csp_numbers_100lens
	
    # STEP 1: Initialize accumulator
    sum = 0  # Start out with nothing
    # STEP 2: GET DATA
    numbers = range(0,101,2)
    # STEP 3: STEP DATA
    for number in numbers:
      # STEP 4: COMBINE
      sum = sum + number
    # STEP 5: RESULT
    print(sum)

.. mchoicemf:: csp_numbers_addodds
   :answer_a: Changed the range step from 2 to 3
   :answer_b: Changed the range end from 101 to 100
   :answer_c: Changed the range end from 101 to 99
   :answer_d: Changed the range start from 0 to 1
   :correct: d
   :feedback_a: No, that would give us [0,3,6,9,12...99].
   :feedback_b: No, that would give us the even numbers from 0 to 98.
   :feedback_c: No, that would give us the even numbers from 0 to 98.
   :feedback_d: Right! That would give us [1,3,5,...99].

   Change the above program to add up all the ODD numbers up to 100.  You should run it to get 2500. What change did you make to the program?

Teacher Note: Print() is your friend
----------------------------------------
|teachernote| The goal of this stage of computing is to develop a mental model.  Can students look at a program and *predict* what's going to happen?  Can they figure out the values of the variables?  Feel free to insert lots of print() function calls.  Have students make a prediction about variable values, then insert print() calls to display the variable values, and run the program to find out whether the prediction is right.  Try this version to see what's going on in the program.

.. activecode:: csp_numbers_100print
	
    # STEP 1: Initialize accumulator
    sum = 0  # Start out with nothing
    # STEP 2: GET DATA
    numbers = range(0,101,2)
    print("All the numbers:",numbers)
    # STEP 3: STEP DATA
    for number in numbers:
      print("Number:",number)
      # STEP 4: COMBINE
      sum = sum + number
    # STEP 5: RESULT
    print(sum)


Playing with words
--------------------

.. index::
    single: words
    single: strings
	single: for loop

Python already has built in the ability to play with words in the same way that Logo students did.  A collection of letters and numbers and other characters inside of quotes is called a *string*. A Python for loop knows how to step through letters, and addition ("+") adds What's fun is that the same accumulator pattern works.

.. |audiobutton| image:: Figures/start-audio-tour.png

Be sure to press the |audiobutton| to get an explanation for how this program works.

.. activecode:: csp_words_1
    :tour_1: "Line-by-line": 1:copyline1; 2:copyline2; 4:copyline4; 6,8:copyline6-8; 8:copyline8; 10:copyline10;

    # STEP 1: Initialize accumulator
    newstring = ""
    # STEP 2: GET DATA
    phrase = "Rubber baby buggy bumpers."
    # STEP 3: STEP DATA
    for letter in phrase:
      # STEP 4: COMBINE
      newstring = newstring + letter
    # STEP 5: RESULT
    print(newstring)

Run this program.  Enh, not that interesting, eh?  Just repeats the string. 

Run this next one, and look at how a simple change to the pattern gives a very different result.    Here we'll combine *before* rather than *afterward*, changing only Step 4.

.. activecode:: csp_words_2
	
    # STEP 1: Initialize accumulator
    newstring = ""
    # STEP 2: GET DATA
    phrase = "Happy Birthday!"
    # STEP 3: STEP DATA
    for letter in phrase:
      # STEP 4: COMBINE
      newstring = letter + newstring
    # STEP 5: RESULT
    print(newstring)

And this one is even more surprisng.

.. activecode:: csp_words_3
	
    # STEP 1: Initialize accumulator
    newstring = ""
    # STEP 2: GET DATA
    phrase = "This is a test"
    # STEP 3: STEP DATA
    for letter in phrase:
      # STEP 4: COMBINE
      newstring = letter + newstring + letter
    # STEP 5: RESULT
    print(newstring)

Try changing the phrase and see what effects you can generate.

.. mchoicemf:: csp_numbers_mirror
   :answer_a: Make the phrase "Time to panic!"
   :answer_b: Make the newstring at the start equal to "!" instead of ""
   :answer_c: Change assignment to **letter + "!" + newstring + letter**
   :answer_d: Change assignment to **letter + newstring + "!" + letter**
   :correct: b
   :feedback_a: No, that would give us **!cinaP ot emiTTime to Panic!**.
   :feedback_b: Yes. We can start our accumulator with something in it.
   :feedback_c: No, that would give us **!!c!i!n!a!P! !o!t! !e!m!i!T!Time to Panic!** -- exclamation points between the letters in the first half of the mirror.
   :feedback_d: No, that would give us **!cinaP ot emiT!T!i!m!e! !t!o! !P!a!n!i!c!!** -- exclamation points between the letters in the second half of the mirror.

   Change the mirroring program to mirror the phrase "Time to Panic" with a single exclamation point in the middle, to make the printed words look like this: **cinaP ot emiT!Time to Panic**.  How do you do it?

The accumulator doesn't have to be set to be an empty string.  You can put something in the accumulator, and then it will show up in the middle of the mirrored phrase.

.. codelens:: charInMiddle

    # STEP 1: Initialize accumulator
    newstring = "!"
    # STEP 2: GET DATA
    phrase = "We're off to see the Wizard!"
    # STEP 3: STEP DATA
    for letter in phrase:
      # STEP 4: COMBINE
      newstring = letter + newstring + letter
    # STEP 5: RESULT
    print(newstring)

.. mchoicemf:: countTheExclamations
   :answer_a: One
   :answer_b: Two
   :answer_c: Three
   :answer_d: Four
   :correct: a
   :feedback_a: Right -- just the one in the accumulator to start.
   :feedback_b: No. If we just mirrored the string, there would be only two.  But we are mirroring with something in the accumulator.
   :feedback_c: That is true at the end, but not when letter is at the first letter of "Wizard"
   :feedback_d: No, at most, there will be three in `newstring`.

   When the variable `letter` contains the "W", how many exclamation points are in `newstring`?

.. parsonsprob:: csp_words_palindrome

   <p>The phrase "A man, a plan, a canal: Panama" is a *palindrome*.  The letters are the same forward and backward.  The below program generates the output: "amanap lanac a nalp a nam a<=>a man a plan a canal panama"  Put the lines in the right order.</p>
   -----
   newstring = "<=>"
   phrase = "a man a plan a canal panama"
   for letter in phrase:
     newstring = letter + newstring + letter
   print(newstring)

The characters in a string have indices
------------------------------------------

.. index::
    single: index
    single: len()
    single: length (of string or list)

One of the powerful ideas in computing is that *the items inside a collection have numbered positions*.  We call those numbered positions the *index*.  Think of each index as the address of the corresponding letter. The letters in a string each have a corresponding number.  The *len()* function tells us the length of a string.  The addresses of the letters start with *zero*.  We use square brackets like this [] to get the character at a given address.

If *name* is "Abraham" then
  - name[0] is "A" 
  - name[1] is "b"
  - len("Abraham") is 7
  - name[6] is "m"

.. activecode:: firstlen

  string = "To infinity and beyond!"
  print("Length of string:")
  print(len(string))
  print("First two characters:")
  print(string[0])
  print(string[1])
  print("First 10 characters:")
  for index in [0,1,2,3,4,5,6,7,8,9,10]:
    print(string[index])
  print("Again first 10 characters:")
  for index in range(11):
    print(string[index])
  print("All the characters:")
  for index in range(len(string)):
    print(string[index])

.. mchoicemf:: csp_numbers_mirror
   :answer_a: print(string[0])
   :answer_b: print(string[index])
   :answer_c: print(string[7])
   :answer_d: print(string[6])
   :correct: d
   :feedback_a: No, that would give us the first character, "H".
   :feedback_b: Only if index already was equal to 6.
   :feedback_c: No.  "w" is the 7th character, but character addresses (indices) start with zero.
   :feedback_d: Yes, because "w" is the 7th character, 6th index (starting with zero) in "Hello world!"
   
   If string = "Hello world!" what will print out a "w"?

We can use our accumulator pattern to collect only certain characters from a string.  We are only changing STEP 3 in these examples.

.. activecode:: accumulateparts

    # STEP 1: Initialize accumulator
    newstring = ""
    # STEP 2: GET DATA
    string = "To infinity and beyond!"
    # STEP 3: STEP DATA
    for index in range(0,11):
      # STEP 4: COMBINE
      newstring = newstring + string[index]
    # STEP 5: RESULT
    print(newstring)

.. mchoicemf:: csp_words_accumulatepartsby2
   :answer_a: "T niiy"
   :answer_b: "oifnt"
   :answer_c: "To infinity"
   :answer_d: " ytinifni o"
   :correct: a
   :feedback_a: Yup -- first ten characters, skipping every other
   :feedback_b: No. we would get this with range(1,11,2)
   :feedback_c: No, we would get this with range(0,11) or range(11)
   :feedback_d: No, we would get this with range(11,0,-1)
   
   WAIT!  **BEFORE** you run the below program, look at it and **PREDICT** what the output will be.

.. activecode:: accumulatepartsby2

    # STEP 1: Initialize accumulator
    newstring = ""
    # STEP 2: GET DATA
    string = "To infinity and beyond!"
    # STEP 3: STEP DATA
    for index in range(0,11,2):
      # STEP 4: COMBINE
      newstring = newstring + string[index]
    # STEP 5: RESULT
    print(newstring)

We can specify *exactly* which characters we want by listing just the index numbers for the `range` function.

.. activecode:: justinfinity

    # STEP 1: Initialize accumulator
    newstring = ""
    # STEP 2: GET DATA
    string = "To infinity and beyond!"
    # STEP 3: STEP DATA
    for index in [3,4,5,6,7,8,9,10]:
      # STEP 4: COMBINE
      newstring = newstring + string[index]
    # STEP 5: RESULT
    print(newstring)

The character indices do *not* have to be in order, and repetition is fine.

.. activecode:: csp_words_message

    # STEP 1: Initialize accumulator
    newstring = ""
    # STEP 2: GET DATA
    string = "To infinity and beyond!"
    # STEP 3: STEP DATA
    for index in [4, 1, 2, 10, 1, 2, 10, 1, 22]:
      # STEP 4: COMBINE
      newstring = newstring + string[index]
    # STEP 5: RESULT
    print(newstring)

.. mchoicemf:: csp_numbers_messageq
   :answer_a: "No way!"
   :answer_b: "To new york!"
   :answer_c: "To infinity!"
   :answer_d: "no yo yo!"
   :correct: d
   :feedback_a: No capital "N" in the original string, so probably not.
   :feedback_b: No "w" in the original string
   :feedback_c: Not the right characters.
   :feedback_d: Yes! Character 4 is "n" and "o" is 1 and...
   
   Try the last example above -- what message does it print?

Now try the string "Rubber baby buggy bumpers" with the index list [14, -1, -1, 6, 14, -1, -1, 6, 14, 8, 8, 6, 14, 8, 8].  What is the hidden message?

Teacher Note: Indices as Addresses
----------------------------------------
|teachernote| The concept of an index can be very challenging for students.  The number 1 in a program could mean the integer 1, or could mean the second character in a string, all depending on how the number 1 is used.  Some of the ways that you might try to emphasize the idea:

- If your students know cartesian coordinate systems well (i.e., x,y positions on a graph), you can talk about x and y as "indices" indicating a position on the graph.
- Have your students line up along a whiteboard, with positional numbers above them.  Give them commands by index number, e.g., "Student at position 1, swap positions with the student as position 0."
- The game *Battleship* is an example of finding a ship by its indices.  The *CS Unplugged* activity on battleships uses indices: http://csunplugged.org/searching-algorithms.


The items in a list have indices
-------------------------------------

Just as characters in a string have indices (addresses), so do items in a list.  In these examples, we are going to generate *two* lists with the `range` function.  One list will be the numbers that we will be manipulating.  The second list will be the indices of which numbers we want.

.. activecode:: csp_words_numbers

    # STEP 1: Initialize accumulator
    sum = 0  # Start out with nothing
    # STEP 2: GET DATA
    numbers = range(0,101)
    # STEP 3: STEP DATA
    indices = range(0,len(numbers))
    for index in indices:
      # STEP 4: COMBINE
      sum = sum + numbers[index]
    # STEP 5: RESULT
    print(sum)

Just like with letters, we can grab every other number in the list.

.. activecode:: csp_words_numbers_by2

    # STEP 1: Initialize accumulator
    sum = 0  # Start out with nothing
    # STEP 2: GET DATA
    numbers = range(0,101)
    # STEP 3: STEP DATA
    indices = range(0,len(numbers),2)
    for index in indices:
      # STEP 4: COMBINE
      sum = sum + numbers[index]
    # STEP 5: RESULT
    print(sum)


But we could set the `numbers` data to be something else, say, the heights of people in the class, and print the average.

.. activecode:: csp_words_average

    # STEP 1: Initialize accumulator
    sum = 0  # Start out with nothing
    # STEP 2: GET DATA
    numbers = [62,61,62,58,65,57,60,59,58,61]
    # STEP 3: STEP DATA
    indices = range(0,len(numbers))
    for index in indices:
      # STEP 4: COMBINE
      sum = sum + numbers[index]
    # STEP 5: RESULT
    print("sum:")
    print(sum)
    count = len(numbers)
    print("average height:")
    print(sum/count)

.. mchoicema:: csp_words_average_score
		  :answer_a: 91.25
		  :answer_b: 92
		  :answer_c: 91
		  :answer_d: 89
		  :correct: a
		  :feedback_a: Good job!
		  :feedback_b: Did you try it? Use this for line 4: numbers = [89, 92,87, 97]
		  :feedback_c: Did you try it? Use this for line 4: numbers = [89, 92,87, 97]
		  :feedback_d: Did you try it? Use this for line 4: numbers = [89, 92,87, 97]

	   	  In your class where you had four exams, your scores were 89, 92, 87, and 97.  What is your average in the class?  Why, you handily happen to have an average-computing program right there!

