..  Copyright (C)  Mark Guzdial, Barbara Ericson, Briana Morrison
    Permission is granted to copy, distribute and/or modify this document
    under the terms of the GNU Free Documentation License, Version 1.3 or
    any later version published by the Free Software Foundation; with
    Invariant Sections being Forward, Prefaces, and Contributor List,
    no Front-Cover Texts, and no Back-Cover Texts.  A copy of the license
    is included in the section entitled "GNU Free Documentation License".

..  shortname:: Chapter: What a Computer Can Do
..  description:: A computer can make loops and patterns.

.. setup for automatic question numbering.

.. 	qnum::
	:start: 1
	:prefix: csp-1-


***********************************
Chapter: What a Computer Can Do
***********************************

What this book is about
-------------------------------

.. video:: preface_video
   :controls:
   :thumb: ../_static/Preface-video-still.png

   http://www.cc.gatech.edu/~mark.guzdial/videos/Preface-video.mov
   http://www.cc.gatech.edu/~mark.guzdial/videos/Preface-video.webm


What makes a computer amazing
-------------------------------

A computer can do lots of things, but a bunch of those things can be thought about in terms of loops and patterns. 

- A computer never gets bored. Ever.  You can make it repeat the same process over and over and over again.  Much of the amazing things that computers can do is by simply repeating a simple series of steps *forever*.

- Most programs can be described in terms of a pattern.  That pattern defines the things that you need to tell the computer to do.  If you learn the patterns, you can build a lot of useful programs by picking a pattern and filling in those steps.

In this chapter, you will run programs that will do interesting things.  You will see the patterns that make those programs work.  Don't worry about being able to *write* these kinds of programs, at least not right now.  Rather, this chapter is about pointing out what the programs can do, and taking a helicopter tour of the programs that can do those things.  In later chapters, you will learn how those programs work, then how you can make your own programs, and how we make programs to make our programming patterns easier.

Seymour Papert, Kids, and Computers
----------------------------------------

Seymour Papert first proposed kids using computers in the 1960's, and the immediate response from many was, *"Why?"*  Computers were used by the military, to do things like figure out how to aim a missile.  Computers were used by scientists and engineers, to do calculations like how much thrust was needed to take off from the moon.  Computers were used by business people, to compute accounts receivable.  Most of the kids Seymour worked with didn't know what accounts recievable were, were not trying to take off from the moon, and shouldn't really be playing with missiles.

But Seymour thought that kids would get a lot out of using computers.  Particularly, Seymour wanted kids to *program* computers.  Programming a computer requires the programmer to tell the computer what to do in terms that the computer understands -- which isn't much.  So, the programmer ends up thinking carefully about *how* things are done.  Essentially, the programmer is a *teacher*, explaining the process to the computer-student in simple terms that the computer-student knows.  By *teaching* the computer, Seymour believed that kids would come to think about knowledge in a new way.  The computer would become *a tool to think with*.

A lot of people thought that these were pretty crazy notions in the 1960's.  Computers were the size of filing cabinets and were very expensive.  And what would kids *do* with the computer anyway?

The sections of this chapter will show off some of what we will do with the computer in this book.  You are welcome (encouraged, even) to change and explore these programs -- but you don't have to.  We will edit programs and write programs in future chapters.  In this chapter, the goal is to an overview of where we're going.

The next chapters are:

- What are the basic abilities of a computer, and how do we use them.
- How do we use the boredom-less repeating of the computer to process lots of data.
- How do we use abstraction to make more powerful and complex patterns without much work at all.
